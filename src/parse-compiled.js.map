{"version":3,"sources":["parse.js"],"names":[],"mappings":"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","file":"parse-compiled.js","sourcesContent":["//parse.js\n/**\n * Created by David Breuer on 15/12/15.\n *\n * @file parse.js\n * @description\n *\n */\n'use strict';\n\nvar esprima = require('esprima');\nvar estraverse = require('estraverse');\nvar escope = require('escope');\nvar _ = require('lodash');\n\nvar config = require('./config');\nvar UserError = require('./error/UserError');\n\n////////\n\nmodule.exports = parse;\n\n////////\n\n\nfunction parse(source) {\n    var ast;\n    try {\n        ast = esprima.parse(source);\n    } catch (err) {\n        throw new UserError('Source file is not valid.', err);\n    }\n\n    var scopeManager = escope.analyze(ast);\n\n    // global scope\n    var currentScope = scopeManager.acquire(ast);\n\n    var calls = [];\n\n    estraverse.traverse(ast, {\n        enter: function (node) {\n            // find all call expressions, because all angular unit types are\n            // defined as function calls: .controller(), .service(), etc\n            if (node.type === 'CallExpression') {\n\n                var calleeProp = _.get(node, 'callee.property', {});\n\n                if (_.contains(config.units.process, calleeProp.name)) {\n                    // save matching node with an appropriate scope\n                    calls.push({\n                        node: node,\n                        scope: currentScope\n                    });\n                }\n\n            }\n\n            // update current scope while traversing\n            // taken from original repository: https://github.com/estools/escope\n            if (/Function/.test(node.type)) {\n                currentScope = scopeManager.acquire(node);\n            }\n        },\n        leave: function (node) {\n            if (/Function/.test(node.type)) {\n                currentScope = currentScope.upper;\n            }\n        }\n    });\n\n\n    var units = [];\n\n    _.forEach(calls, function (call) {\n        // for now use only completely parsed units\n        var name = findName(call.node, call.scope);\n        if (_.isUndefined(name)) { return; }\n\n        var type = findType(call.node, call.scope);\n        if (_.isUndefined(type)) { return; }\n\n        var module = findModule(call.node, call.scope);\n        if (_.isUndefined(module.name)) { return; }\n\n        var deps = findDeps(call.node, call.scope, type);\n\n        // Angular should not allow having circular dependency, but if\n        // there is any in a source code, do not continue execution\n        if (_.findWhere(deps, { name: name })) {\n            throw new UserError('Circular dependency for ' + type + ' \"' + name + '\".');\n        }\n\n        var unit = {\n            name: name,\n            type: type,\n            module: module,\n            deps: deps\n        };\n\n        units.unshift(unit);\n    });\n\n    return units;\n}\n\n\n////////\n\n\nfunction findName(callExpression) {\n    var name;\n\n    var nameArg = _.get(callExpression, 'arguments[0]', {});\n    if (nameArg.type === 'Literal') {\n        name = nameArg.value;\n    }\n\n    return name;\n}\n\n\nfunction findType(callExpression) {\n    return _.get(callExpression, 'callee.property.name');\n}\n\n\n// TODO: multiple variable definitions\nfunction findModule(callExpression, scope) {\n    var module = {};\n\n    var calleeObj = _.get(callExpression, 'callee.object', {}),\n        calleeProp = _.get(callExpression, 'callee.property', {});\n\n    if (calleeObj.type === 'CallExpression') {\n        // recursive find module, usually when units are chained\n        return findModule(calleeObj, scope);\n\n    } else if (calleeObj.type === 'Identifier') {\n        // when reaching module variable it can be in a form of \"angular.module(..)\"\n        if (calleeProp.name === 'module' && calleeObj.name === 'angular') {\n\n            module.name = _.get(callExpression, 'arguments[0].value');\n\n            // or module can be stored in variable; find this variable then\n        } else if (_.contains(config.units.process, calleeProp.name)) {\n\n            var varName = calleeObj.name;\n            var varNode = findVariable(varName, scope);\n            if (varNode) {\n                module.name = _.get(varNode, 'init.arguments[0].value');\n            }\n\n        }\n\n    }\n\n    return module;\n}\n\n\n// TODO: multiple variable definitions\nfunction findDeps(callExpression, scope, type) {\n\n    var cantHaveDeps = ['filter', 'value', 'constant'];\n    if (_.contains(cantHaveDeps, type)) {\n        return [];\n    }\n\n    // first argument is a name of the unit, second - usually has deps\n    var depsArg = _.get(callExpression, 'arguments[1]', {});\n    var deps = [];\n\n    // deps can be provided explicitly as an array\n    // in this case a body of the unit is the last array element\n    if (depsArg.type === 'ArrayExpression') {\n        var lastDepsArg = _.last(depsArg.elements) || {};\n        if (lastDepsArg.type === 'FunctionExpression') {\n            return extractDeps(lastDepsArg.params);\n        }\n    }\n\n    // deps in a form of function expression can be stored in variable\n    if (depsArg.type === 'Identifier') {\n        return extractVariableDeps(depsArg.name, scope);\n    }\n\n    // deps in a form of function expression\n    if (depsArg.type === 'FunctionExpression') {\n\n        // everything except provider usually stores deps as function arguments\n        if (type !== 'provider') {\n            return extractDeps(depsArg.params);\n        }\n\n        // provider has a lot more complex structure because of $get construct\n        // it may vary a lot, covering common cases\n        return findProviderDeps(depsArg);\n    }\n\n    return deps;\n}\n\n\nfunction findProviderDeps(depsFn) {\n    // function must have it's body\n    var depsFnBody = _.get(depsFn, 'body', {});\n    if (depsFnBody.type !== 'BlockStatement') {\n        return [];\n    }\n\n    // find a scope of provider body\n    var depsFnScope = findScope(depsFn);\n\n    var deps = [];\n\n    // iterate over all body expressions in provider\n    var depsFnBodyExpressions = _.get(depsFnBody, 'body');\n    _.some(depsFnBodyExpressions, function (bodyExpression) {\n\n        var type = _.get(bodyExpression, 'type');\n\n        var expression = _.get(bodyExpression, 'expression', {});\n        var leftProp = _.get(expression, 'left.property', {});\n        var right = _.get(expression, 'right', {});\n\n        // covers \"this.$get = ...\"\n        if (type === 'ExpressionStatement' && leftProp.name === '$get') {\n\n            // covers \"this.$get = function (...) { ... };\"\n            if (right.type === 'FunctionExpression') {\n                deps = extractDeps(right.params);\n                return true; // exit loop\n            }\n\n            // covert \"this.$get = someVar;\"\n            if (right.type === 'Identifier') {\n                deps = extractVariableDeps(right.name, depsFnScope);\n                return true; // exit loop\n            }\n\n        }\n\n        var argument = _.get(bodyExpression, 'argument', {});\n\n        // covers \"return ...;\"\n        if (type === 'ReturnStatement') {\n\n            // covers \"return { $get: function () {} };\"\n            // covers \"return { $get: someVar };\"\n            if (argument.type === 'ObjectExpression') {\n                deps = extractObjectPropertyDeps(argument, '$get', depsFnScope);\n                return true;\n            }\n\n            // covers \"return someVar;\"\n            if (argument.type === 'Identifier') {\n\n                var varNode = findVariable(argument.name, depsFnScope);\n                if (varNode && _.get(varNode, 'init.type') === 'ObjectExpression') {\n                    deps = extractObjectPropertyDeps(varNode.init, '$get', depsFnScope);\n                    return true;\n                }\n\n            }\n\n        }\n\n    });\n\n    return deps;\n}\n\n\nfunction extractDeps(params) {\n    if (!_.isArray(params)) {\n        return [];\n    }\n\n    var deps = [];\n    _.forEach(params, function (param) {\n        if (param.type === 'Identifier') {\n\n            var dep = {\n                name: param.name\n            };\n\n            deps.push(dep);\n        }\n    });\n    return deps;\n}\n\n\nfunction findVariable(varName, scope) {\n    var variable;\n    var currentScope = scope;\n\n    while (!variable && currentScope) {\n        variable = _.findWhere(currentScope.variables, { name: varName });\n        currentScope = currentScope.upper;\n    }\n\n    if (_.isUndefined(variable)) {\n        return variable;\n    }\n\n    var node = _.get(variable, 'defs[0].node');\n\n    return node;\n}\n\n\nfunction extractVariableDeps(varName, scope) {\n    var varNode = findVariable(varName, scope);\n    if (!varNode) {\n        return [];\n    }\n\n    var params = [];\n\n    var varType = _.get(varNode, 'type');\n\n    // covers \"function someVar() {}\"\n    if (varType === 'FunctionDeclaration') {\n        params = _.get(varNode, 'params', []);\n    }\n\n    // covers \"var someVar = ...\";\n    if (varType === 'VariableDeclarator') {\n        params = _.get(varNode, 'init.params', []);\n    }\n\n    var deps = extractDeps(params);\n\n    return deps;\n}\n\nfunction extractObjectPropertyDeps(object, propName, scope) {\n\n    var prop = _.find(object.properties, function (property) {\n        return _.get(property, 'key.name') === propName;\n    });\n\n    if (!prop) {\n        return [];\n    }\n\n    var value = _.get(prop, 'value', {});\n\n    var deps = [];\n\n    // covers \"{ key: function () {} }\"\n    if (value.type === 'FunctionExpression') {\n        deps = extractDeps(value.params);\n    }\n\n    // covers \"{ key: someVar }\"\n    if (value.type === 'Identifier') {\n        deps = extractVariableDeps(value.name, scope);\n    }\n\n    return deps;\n}\n\n\nfunction findScope(ast) {\n    var scopeManager = escope.analyze(ast);\n    var scope = scopeManager.acquire(ast);\n    return scope;\n}\n\n"]}